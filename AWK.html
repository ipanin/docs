<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="Keywords" content="AWK руководство ДЕМОС">
<meta name="Description" content="Old Soviet guide for AWK">
<style>
  body pre {
    font-family: "Courier New", Courier, "monospace";
  }
</style>

<title>Язык обработки структурированных текстов AWK</title>
</head>
<body>
<h2>Язык обработки структурированных текстов AWK</h2>
<pre>

<hr/>


          Производственно-внедренческий кооператив

                    "И Н Т Е Р Ф Е Й С"








                Диалоговая Единая Мобильная

                    Операционная Система

                        Демос/P 2.1







        Язык обработки структурированных текстов AWK










                           Москва

                            1988


<hr/>


<h3 id="contents">Содержание</h3>
<ol start="0">
  <li style="list-style-type:none"><a href="#annotation">Аннотация</a></li>
  <li><a href="#ch1">Принципы работы интерпретатора awk</a></li>
  <li><a href="#ch2">Переменные, выражения и присваивания в AWK-программах</a></li>
  <li><a href="#ch3">Структура AWK-программы</a></li>
  <li><a href="#ch4">Селекторы</a></li>
  <li><a href="#ch5">Действия</a></li>
  <li><a href="#ch6">Ввод и вывод данных в AWK-программах</a></li>
  <li><a href="#ch7">Использование встроенных функций</a></li>
</ol>


<h3 id="annotation">Аннотация</h3>

     Язык AWK  используется  для  комбинированной  обработки
символьных и числовых полей в записях.  В результате генери-
руется отчет в запланированной программистом  форме.   Прог-
раммы на языке AWK можно эффективно использовать как фильтры
данных для преобразования вывода одной программы и  передачи
результата фильтрации на вход другой.  В системе ДЕМОС уста-
новлен интерпретатор языка  AWK,  который  получил  название
<b>awk</b>.



<h3 id ="ch1">1.  Принципы работы интерпретатора awk</h3>


     Любой текст имеет  некоторую  структуру,  в  простейшем
случае  ее  элементами  являются  строки  и слова текста.  В
языке AWK текст рассматривается как список записей и полей в
них  и  на  этой  основе  выполняется некоторый определенный
программистом алгоритм обработки. Допустим, имеется  следую-
щий текст:

Сидоров Сидор  Сидорович      1957 г.р. 220 руб сл.
Петров  Петр   Иванович       1962 г.р. 200 руб сл.
Иванов  Михаил Константинович 1965 г.р. 180 руб раб.
Волков  Леонид Николаевич     1950 г.р. 280 руб раб.
Семенов Петр   Михайлович     1958 г.р. 210 руб раб.

Этот текст структурирован: записи - это строки, поля в стро-
ках - слова и числа.  В каждой записи содержится по 8 полей,
разделяющихся пробелами.  Значащим (в качестве  разделителя)
является  только один пробел между полями, остальные игнори-
руются.  Рассмотрим несколько простых программ на языке AWK.

     <b>Пример 1.</b> AWK-программа  выводит  первые  три  поля  из
восьми,  порядок полей в выводе изменен и перед каждой стро-
кой печатается символ табуляции

    <b>{ print</b>( "\t", $2, $3, $1 )<b>; }</b>

Оператор <b>print</b> выполняется для всех входных записей.   После
выполнения программы получим:

    Сидор Сидорович Сидоров
    Петр Иванович Петров
    Михаил Константинович Иванов
    Леонид Николаевич Волков
    Владимир Михайлович Семенов

Как видно из программы, значения полей подставляются следую-
щим образом:

    $<b>номер_поля_в_записи</b>

Первому полю соответствует 1.  В общем случае  номером  поля
может  быть  значение  выражения.  Значением  подстановки $0
является вся запись.

     <b>Пример 2.</b>  AWK-программа  выводит  номера  строк  после
табуляции

    <b>{ print</b>( "\t", <b>NR</b>, $2, $3, $1 )<b>; }</b>

После выполнения программы получим:

    1 Сидор Сидорович Сидоров
    2 Петр Иванович Петров
    3 Михаил Константинович Иванов
    4 Леонид Николаевич Волков
    5 Владимир Михайлович Семенов

Предопределенная переменная <b>NR</b> равна  номеру  обрабатываемой
записи.   Мы  воспользовались  ее  значением  для  нумерации
строк.

     <b>Пример 3.</b> AWK-программа выводит  полное  число  лет  на
1988 год каждому лицу из списка

<b>{ print</b>("\t", <b>NR</b>, $2, $3, $1, "\t\t", 1988 - $4)<b>; }</b>

После выполнения программы получим:

    1 Сидор Сидорович Сидоров                31
    2 Петр Иванович Петров                   26
    3 Михаил Константинович Иванов           23
    4 Леонид Николаевич Волков               38
    5 Владимир Михайлович Семенов            30


     <b>Пример 4.</b> AWK-программа подсчитывает средний возраст  и
среднюю заработную плату перечисленных в списке лиц

    <b>{</b>
          <b>age +=</b> 1988 <b>- </b>$4;
          <b>pay += </b>$6;
    <b>}</b>

    <b>END     {</b>
        <b>print</b> ("Средний  возраст:\t",  <b>age/NR</b> );
        <b>print</b> ("Средняя зарплата:\t",  <b>pay/NR</b> );
    <b>}</b>

После выполнения программы получим:

    Средний  возраст:        29.6
    Средняя зарплата:        218

Когда необходимо обеспечить вывод результата  по  завершению
списка записей, используется селектор <b>END</b>.  Переменные <b>age</b> и
<b>pay</b> определяются автоматически как числа  в  момент  первого
использования.  Выражения вычисляются для всех входных запи-
сей.

     <b>Пример 5.</b> AWK-программа подсчитывает средние возраст  и
заработную  плату рабочих и служащих в списке. Для выделения
строк со сведениями о рабочих используется шаблон  <b>/</b>раб<b>/</b>,  о
служащих - шаблон <b>/</b>сл<b>/</b>.  Шаблоны содержат образцы для поиска
в полях  записи.   Данные  выводятся  после  обработки  всех
записей.

<b>/</b>раб<b>/   {</b>
    <b>rage +=</b> 1988 <b>- </b>$4;
    <b>rpay += </b>$6;
    <b>r++;</b>
<b>}</b>

<b>/</b>сл<b>/    {</b>
    <b>age +=</b> 1988 <b>- </b>$4;
    <b>pay += </b>$6;
    <b>c++;</b>
<b>}</b>

<b>END     {</b>
    <b>print</b>("\t\tСредний возраст  Средняя зарплата\n");
    <b>print</b>(" Рабочие:\t", <b>rage/r</b>, "\t",    <b>rpay/r</b> );
    <b>print</b>("Служащие:\t",  <b>age/c</b>, "\t\t",  <b>pay/c</b> );
<b>}</b>

После выполнения программы получим:

             Средний возраст  Средняя зарплата

 Рабочие:        30.3333         223.333

Служащие:        28.5            210

Программа выполняется  следующим  образом.   Если  запись  в
каком-либо  из полей содержит образец, выполняется действие,
записанное в фигурных скобках рядом с соответствующим шабло-
ном,  иначе  действие  не  выполняется.  Действия, указанные
после <b>END</b>, выполняются по концу списка записей.   Шаблоны  в
примере  используются  как селекторы входных записей: если в
четвертом примере действия были выполнены для  всех  входных
записей, то в этом - только для отобранных по образцам, ука-
занным в шаблонах. При этом <b>END</b>  используется  как  селектор
специального  вида:  он  определяет  список  операторов AWK-
программы, который должен выполниться после завершения вход-
ного потока записей.

     <b>Пример 6.</b>  AWK-программа  вычисляет  уровни  заработной
платы

<b>BEGIN  {</b>
    <b>Min</b> = 1000;
    <b>Max</b> = 0;
<b>}</b>

<b>{</b>
    <b>if</b> ( $6 &lt; <b>Min</b> ) <b>{</b>
        Min = $6;
        smin = $1 " " $2 " " $3;
    <b>}</b>

    <b>if</b> ( $6 &gt; <b>Max</b> ) <b>{</b>
        Max = $6;
        smax = $1 " " $2 " " $3;
    <b>}</b>
<b>}</b>

<b>END {</b>
    <b>print</b>( "\t\tУровни зарплаты\n" );
    <b>print</b>( " Минимальный: ", <b>Min</b>, "  (",<b>smin</b>,")" );
    <b>print</b>( "Максимальный: ", <b>Max</b>, "  (",<b>smax</b>,")" );
<b>}</b>

После выполнения получим:

                Уровни зарплаты

 Минимальный:  180   ( Иванов Михаил Константинович )

Максимальный:  280   ( Волков Леонид Николаевич )

В этой программе три раздела. Первый раздел используется для
установки  начальных  значений  переменных  <b>Max</b> и <b>Min</b> еще до
чтения записей из списка.  Специальный селектор <b>BEGIN</b>  опре-
деляет   список  операторов  AWK-программы,  который  должен
выполниться до анализа первой записи из входного потока.  Во
втором  разделе осуществляется собственно обработка записей.
Операторы этого раздела программы выполняются для всех вход-
ных  записей,  так  как  селектор  не указан.  Третий раздел
выполняется когда завершается список записей (селектор <b>END</b>).
В строке

    <b>smin = </b>$1 " " $2 " " $3;

переменной <b>smin</b> присваиваются  значения  первых  трех  полей
записи,  конкатенация которых вместе с пробелами, указанными
в кавычках, образует строку. Таким образом  значением  пере-
менной   <b>smin</b>   будет  строка  символов  типа  "Фамилия  Имя
Отчество".

     Существует  несколько  способов  вызова  интерпретатора
<b>awk</b>.  AWK-программа в файле:

<b>awk -f имя_файла_с_AWK-программой  входной_файл</b> ...

По умолчанию  разделителем  записей  является  символ  новой
строки, разделителем полей - символ пробела и/или табуляции.
Символы-разделители  можно  явно  определить  в   программе.
Символ-разделитель  полей  можно  определить  и  в командной
строке.  Вызов <b>awk</b> с указанием символа-разделителя полей:

<b>awk -Fразделитель -f файл_AWK-программа  входной_файл</b> ...

Часто AWK-программы настолько коротки, что их  целесообразно
указывать  непосредственно в командной строке, а не в файле.
Вызов <b>awk</b> с программой в командной строке:

<b>awk -Fразделитель 'AWK-программа'  входной_файл</b> ...

<b>awk 'AWK-программа' входной_файл</b> ...

Интерпретатор <b>awk</b>, как и большинство  других  программ  сис-
темы, позволяет <b>входной_файл</b> заменить на стандартный ввод.

<b>awk -f имя_файла_с_AWK-программой  -</b>

<b>awk -Fразделитель 'AWK-программа'  -</b>

<b>awk 'AWK-программа' -</b>

Если не указано другое, результат  выполнения  AWK-программы
печатается на экране дисплея.

<h3 id ="ch2">2.  Переменные, выражения и присваивания в AWK-программах</h3>


     В языке AWK выделяют две группы переменных: предопреде-
ленные  и  декларированные  в  программе.   Предопределенные
переменные доступны для подстановок и изменений в программе,
их  исходные  значения устанавливаются интерпретатором <b>awk</b> в
процессе запуска и выполнения AWK-программы.  К  предопреде-
ленным переменным относятся:

<b>NR</b>   номер текущей записи;

<b>NF</b>   число полей в текущей записи;

<b>RS</b>   разделитель записей на вводе (символ);

<b>FS</b>   разделитель полей записи на вводе (символ);

<b>ORS</b>  разделитель записей на выводе AWK-программы (символ);

<b>OFS</b>  разделитель полей записи на выводе (символ);

<b>OFMT</b> формат вывода чисел;

<b>FILENAME</b> имя входного файла (строка).


     По умолчанию имеют место следующие значения предопреде-
ленных переменных:

     <b>RS</b>    =   "\0";
     <b>FS</b>    =   'пробел(ы) и/или табуляция';
     <b>OFS</b>   =   <b>FS</b>;
     <b>ORS</b>   =   <b>RS</b>;
     <b>OFMT</b>  =   "%.6g";

Предопределенным переменным <b>RS</b>, <b>FS</b>,  <b>ORS</b>,  <b>OFS</b>,  <b>OFMT</b>  можно
присваивать значения в AWK-программе.

     В языке AWK отсутствуют декларация и явная  инициализа-
ция  переменной любого типа. Всякой переменной до ее первого
использования присваивается значение "\0" -  пустая  строка.
Применяются следующие типы переменных:

позиционная переменная;

число с плавающей точкой;

строка символов;

массив.

Позиционная переменная определяет  поле  записи,  содержимое
которого   может   быть   отнесено  к  типам   "строка"  или
"число_с_точкой" и используется в виде

    $<b>номер_поля_записи</b>

    $(<b>выражение</b>)

<b>Номер_поля_записи</b> может быть значением выражения.  Значением
позиционной переменной $0 является вся запись.

     Интерпретатор <b>awk</b> рассматривает переменную как  строко-
вую  до  того  момента, когда необходимо выполнить некоторую
операцию над ее значением. В зависимости  от  контекста  тип
значения переменной остается либо строковым, либо преобразу-
ется к типу число_с_точкой. В двусмысленных  случаях   пере-
менные  рассматриваются  как  строковые.  Строки, которые не
могут быть интерпретированы как числа, в числовом  контексте
будут  иметь  числовое значение НОЛЬ.  Устранить двусмыслен-
ность можно явным указанием типа переменной при присваивании
ей значения, например:

<b>name</b> =  1 ;    # присвоено значение 1.0

<b>name</b> = "1";    # присвоено значение строки "1"

При интерпретации выражений существенную  роль  играет  кон-
текст, например:

<b>name</b> =  3  <b>+</b>  2  ;

<b>name</b> =  3  <b>+</b> "2" ;

<b>name</b> = "3" <b>+</b> "2" ;

<b>name</b> =  3  <b>+</b>  2  <b>+</b>  "яблоко груша апельсин";

<b>name</b> = "яблоко" <b>+</b> "груша";

В этом примере в первых четырех случаях <b>name</b>  равно  5.0,  в
пятом - 0.

     Массив не декларируется,  он  начинает  существовать  в
момент  первого использования. Индексы в массиве могут иметь
любое ненулевое значение,  включая  нечисловые  строки,  это
позволяет  использовать  ассоциативные массивы. Например,  в
приведенной ниже AWK-программе будет подсчитано число упоми-
наний об автомобилях различных марок во входном тексте:

<b>/ЗИЛ/  { Автомобили</b>["ЗИЛ"]<b>++; }</b>

<b>/ГАЗ/  { Автомобили</b>["ГАЗ"]<b>++; }</b>

<b>/ВАЗ/  { Автомобили</b>["ВАЗ"]<b>++; }</b>

<b>END    {</b>
    <b>print</b>("ЗИЛ : ", <b>Автомобили</b>["ЗИЛ"]);
    <b>print</b>("ГАЗ : ", <b>Автомобили</b>["ГАЗ"]);
    <b>print</b>("ВАЗ : ", <b>Автомобили</b>["ВАЗ"]);
<b>}</b>

Массивы можно использовать для организации такого  алгоритма
обработки  данных, в котором требуется многократный просмотр
входного потока записей.  Например,  если  не  заботиться  о
размерах  оперативной  памяти,  то  можно  весь входной файл
записать в виде массива записей  и  по  завершению  входного
потока приступить собственно к обработке:


{
     <b>Массив_записей</b>[<b>NR</b>] = $0
}

<b>END</b>  {
   ...
    <b>программа обработки массива</b>
   ...
}

В качестве имени (значения) индекса массива можно  использо-
вать выражение, например:

    <b>name</b>["2" <b>* </b>$3]


     В языке AWK используются операторы присваивания

    <b>=   +=   -=   *=   /=   %=</b>

и арифметические операции

    <b>+    -    *    /    %    ++    --</b>

Они имеют тот же смысл, что и в языке программирования Си.

     Имеются некоторые особенности выполнения операций срав-
нения

    <b>&lt;    &lt;=    ==    !=     &gt;=     &gt;</b>

Если оба операнда интерпретируются как числа, то выполняется
сравнение  чисел.   Если  один из операндов является строкой
символов, а другой - числом, то выполняется сравнение строк.
Сравнение  строк заключается в попарном сравнении внутренних
кодов символов строк до первого  неравенства  кодов  или  до
завершения одной из строк. Рассмотрим пример:

<b>{</b>
 <b>if</b>( $1 &lt; $2 )
   <b>print</b>(<b>NR</b>": $1 =", $1, "; $2 =", $2, "; $1 &lt; $2");

 <b>if</b>( $1 <b>== </b>$2 )
   <b>print</b>(<b>NR</b>": $1 =", $1, "; $2 =", $2, "; $1 == $2");

 <b>if</b>( $1 &gt; $2 )
   <b>print</b>(<b>NR</b>": $1 =", $1, "; $2 =", $2, "; $1 &gt; $2");
<b>}</b>

Допустим, имеется следующий входной текст:

    2.01    2.02
    2.01    abc
    a       b
    aa      b
    aa      ab
    aa      ba
    abc     ab
    ab      abc
    ef      abc

В результате выполнения программы получим:

    1: $1 = 2.01; $2 = 2.02; $1 &lt;  $2
    2: $1 = 2.01; $2 = abc ; $1 &lt;  $2
    3: $1 = a   ; $2 = b   ; $1 &lt;  $2
    4: $1 = aa  ; $2 = b   ; $1 &lt;  $2
    5: $1 = aa  ; $2 = ab  ; $1 &lt;  $2
    6: $1 = aa  ; $2 = ba  ; $1 &lt;  $2
    7: $1 = abc ; $2 = ab  ; $1 &gt;  $2
    8: $1 = ab  ; $2 = abc ; $1 == $2
    9: $1 = ef  ; $2 = abc ; $1 &gt;  $2


     В AWK-программах можно использовать следующие  логичес-
кие операции:

    <b>!</b> (не)     <b>||</b> (или)     <b>&&</b>  (и)

Как обычно, значением выражения, содержащего операции  отно-
шения  и/или логические операции, являются: истина (не ноль)
или ложь (ноль).  Приоритеты операций  в  выражениях  анало-
гичны  установленным  в  языке  Си.  Для управления порядком
выполнения операций в выражении используются круглые скобки.

     В языке AWK имеется операция, не предусмотренная в  Си,
- это операция "пробел", которая используется для конкатена-
ции переменных, значения которых интерпретируются как  стро-
ковые

    <b>name</b> = "яблоко " "и груша";

В этом случае значением переменной <b>name</b> будет строка вида

    "яблоко и груша"

Вместо символа пробел можно использовать  символ  табуляции.
При  использовании  операции  "пробел" учитывается контекст,
например:

$1 = "яблоко"

$2 = "и"

$3 = "груша"

<b>name1</b> = $3 $2 $1;              #  1
<b>name2</b> = $3" "$2" "$1;          #  2
<b>name3</b> = "Красное " $1;         #  3
<b>name4</b> = 1 2 3 4 5 6 7 8 9;     #  4
<b>name5</b> = 123           789;     #  5
<b>name6</b> = $3$2$1;                #  6
<b>name7</b> = $3 123;                #  7

значением переменной <b>name1</b> будет строка:

    "грушаияблоко"

Значением переменной <b>name2</b> будет строка:

    "груша и яблоко"

Значением переменной <b>name3</b> будет строка:

    "Красное яблоко"

Значением переменной <b>name4</b> будет строка:

    "123456789"

Значением переменной <b>name7</b> будет строка:

    "груша123"

Значением переменной <b>name5</b> будет строка:

    "123789"

Из примера 5 видно, что в качестве знака  операции  "пробел"
существенно  наличие  лишь  одного пробела между операндами,
остальные игнорируются.  Значением  переменной  <b>name6</b>  будет
строка вида

    "грушаияблоко"

Однако синтаксис, использованный в 6 строке примера,  сомни-
телен  и  не  стоит  полагаться на "мудрость" интерпретатора
<b>awk</b>.

     Позиционные переменные можно использовать в  выражениях
любого вида, им можно присваивать новые значения. Рассмотрим
несколько примеров:

$3  <b>=  </b>$1 " " $2;
$3 <b>+=  </b>$1;
$3  <b>=  </b>$3 $3 $3;
$3  =  "";
$0  <b>=  </b>$3;

В первом  случае  позиционной  переменной  $3  присваивается
строка,  полученная в результате конкатенации значения пози-
ционной переменной $1, пробела и значения позиционной  пере-
менной $2.  Во втором случае значение переменной $3 увеличи-
вается на значение переменной $1.  В третьем случае выполня-
ется  конкатенация  собственного  значения  переменной $3, в
четвертом - переменной  $3  присваивается  значениие  пустой
строки,  в пятом - значение переменной $0 (вся запись) заме-
няется значением поля 3.

<h3 id ="ch3">3.  Структура AWK-программы</h3>


     AWK-программа состоит из списка правил вида:

<b>селектор1</b>     <b>{  действие  }</b>
      ...
<b>селекторN</b>     <b>{  действие  }</b>

Открывающая фигурная скобка должна стоять в той  же  строке,
где селектор. В любом месте программы можно ввести коммента-
рий, он печатается от символа <b>#</b> до конца строки.

     Каждое правило выполняется для каждой записи  из  вход-
ного  потока. Селектор используется для того, чтобы выделить
запись, над которой будет выполнено  действие  соответствую-
щего  правила.  Если запись не выделена ни одним из селекто-
ров, она игнорируется и не выводится на  стандартный  вывод.
Если  запись выделена селектором, выполняется действие соот-
ветсвующего правила. Если  некоторую  запись  выделяют  нес-
колько селекторов, над ней выполняются действия соответству-
ющих правил.

     В правиле может отсутствовать селектор, тогда  действие
этого  правила будет выполнено для всех без исключения вход-
ных записей.  В правиле может отсутствовать действие,  тогда
все  выделенные  селектором записи будут направлены на стан-
дартный вывод без изменений.

     Определены два правила специального вида:

<b>BEGIN         {  действие  }</b>

      ...
<b>список других правил</b>
      ...

<b>END           {  действие  }</b>

Правило с селектором  <b>BEGIN</b>  выполняется  до  чтения  первой
входной  записи,  с  селектором <b>END</b> - после чтения последней
записи.  Правило с селектором <b>BEGIN</b>  должно  быть  первым  в
списке правил, с селектором <b>END</b> - последним.  Возможно такое
использование этих правил:

<b>BEGIN         {  действие  }</b>

      ...
<b>список других правил</b>

или

<b>список других правил</b>
      ...

<b>END           {  действие  }</b>

Действие в  правиле  может  содержать  список  операторов  и
управляющих  конструкций. Оператор должен заканчиваться сим-
волом ";", или символом новой строки, или закрывающей  скоб-
кой.

     Переменную можно  использовать  в  любом  правиле  AWK-
программы,  начиная  с места, где она определена. Рассмотрим
пример, в  котором  демонстрируются  особенности  выполнения
правил AWK-программы и использования переменных:


    <b>#</b> Программа   демонстрирует    работу
    <b>#</b> правил  различного  вида  и область
    <b>#</b> действия переменных

    <b>#</b> Правило 1 выполняется
    <b>#</b> для всех записей

         <b>{ print</b>("Запись номер:", <b>NR</b>)<b>; }</b>

    <b>#</b> Правило  2  выполняется  только для
    <b>#</b> записей, где обнаружен образец aaa

    <b>/</b>aaa<b>/ {</b>
       <b>print</b>("Правило 2:");
       <b>print</b>("     Вход:", $0);
       $1 = $1  $2;
       $2 = "***";
       <b>A  = </b>$2;
       <b>print</b>("Результат:", $0, "A =", <b>A</b>);
    <b>}</b>

    <b>#</b> Правило  3  выполняется  только для
    <b>#</b> записей, где обнаружен образец ddd

    <b>/</b>ddd<b>/ {</b>
       <b>print</b>("Правило 3:");
       <b>print</b>("     Вход:", $0);
       $1 = $1 $3;
       $2 =  "&&&";
       <b>A  = </b>$2;
       <b>print</b>("Результат:", $0, "A =", <b>A</b>);
    <b>}</b>

    <b>#</b> Правило 4 выполняется для всех записей

    <b>{</b>
       <b>print</b>("Правило 4:", $0, "A =", <b>A</b>,"\n");
    <b>}</b>

Допустим, на вход этой программе  передаются  следующие  три
записи:

    eee fff
    ddd eee fff
    aaa bbb ccc ddd eee

тогда после выполнения программы получим:

    Запись номер: 1
    Правило 4: eee fff A =

    Запись номер: 2
    Правило 3:
         Вход: ddd eee fff
    Результат: dddfff &&& fff A = &&&
    Правило 4: dddfff &&& fff A = &&&

    Запись номер: 3
    Правило 2:
         Вход: aaa bbb ccc ddd eee
    Результат: aaabbb *** ccc ddd eee A = ***
    Правило 3:
         Вход: aaabbb *** ccc ddd eee
    Результат: aaabbbccc &&& ccc ddd eee A = &&&
    Правило 4: aaabbbccc &&& ccc ddd eee A = &&&


<h3 id ="ch4">4.  Селекторы</h3>


     Селектор указывается, чтобы определить, будет ли выпол-
няться  действие  в правиле. В качестве селектора может быть
использовано любое выражение, шаблон и произвольная их  ком-
бинация. Рассмотрим несколько примеров использования выраже-
ний в селекторах:

$1 <b>!= </b>$2 <b>|| </b>$1 &gt; 128
     выбрать запись, в которой либо  первые  два  поля  раз-
     личны, либо содержимое первого поля больше 128;

$1 <b>% </b>$2 <b>==</b> 1
     выбрать запись, в  которой  остаток  от  деления  полей
     равен 1;

<b>NF %</b> 2 <b>==</b> 0 <b>|| name</b> &lt; 2.2
     выбрать запись, либо  содержащую  четное  число  полей,
     либо если переменная <b>name</b> меньше 2.2;

     $1 <b>==</b> "Иванов И.И."

     выбрать запись, в которой первое поле относится к  Ива-
нову И.И.;

$1 <b>&gt;=</b> "М" <b>&& </b>$1 <b>!=</b> "Москва"

     выбрать запись, первое поле которой начинается с  буквы
М и далее по алфавиту, но не является словом Москва.

     Шаблон используется для формирования одного  или  боль-
шего  числа  образцов  в селекторе. При сканировании входной
записи осуществляется поиск цепочки символов,  тождественной
образцу.   В  простейшем случае селектор с шаблоном выглядит
следующим образом:

    <b>/образец/</b>

В символах <b>/</b> указан образец, который будет  использован  для
поиска.   Существенно, что любой символ, в том числе пробел,
указанный внутри пары символов <b>/</b>, является частью образца.

     Если необходимо, чтобы соответствие  образцу  определя-
лось  в конкретном поле записи, используются операторы соот-
ветствия (<b>~</b> и <b>!~</b>)

$<b>номер_поля ~  шаблон</b>
     если  при  просмотре  указанной  позиционной  перменной
     обнаруживается  цепочка символов, тождественная образцу
     в шаблоне (оператор <b>~</b>), выполняется действие правила.

$<b>номер_поля !~ шаблон</b>
     если при просмотре указанной позиционной  перменной  не
     обнаруживается  цепочка символов, тождественная образцу
     в шаблоне (оператор <b>!~</b>), выполняется действие правила.


     В  общем  случае  шаблон  может  формировать  множество
образцов  и/или  указывать,  в каком месте записи необходимо
искать соответствие входной цепочки символов  образцу.   При
необходимости используются так называемые регулярные выраже-
ния, в этом случае шаблон выглядит следующим образом:

    <b>/регулярное_выражение/</b>

В результате разбора регулярного  выражения  интерпретатором
<b>awk</b>  строится и выполняется алгоритм поиска одного или боль-
шего числа образцов во входной записи.

     Регулярные выражения в шаблонах селекторов  AWK  анало-
гичны  подобным в <b>lex</b>, редакторе <b>ed</b> и в команде <b>grep</b>.  Регу-
лярное выражение формируется как композиция цепочек символов
(и/или  диапозонов символов) и операторов. Операторы в регу-
лярных выражениях указываются  в  виде  символов-операторов.
Чтобы  отнести действие символа-оператора к отдельному фраг-
менту регулярного выражения,  используются  круглые  скобки.
Чтобы  отменить  специальное значение символа-оператора, его
экранируют символом <b>\</b>.

     Для записи регулярных выражений употребляются следующие
символы-операторы:

<b>^</b>    от начала;

<b>$</b>    на конце;

<b>.</b>    любой символ;

<b>символ</b>
     данный символ, если он не символ-оператор;

<b>\символ</b>
     использовать символ-оператор как обычный символ;

[<b>строка</b>]
     любой из символов данной строки;

[<b>буква1-буква2</b>]
     любая буква из данного лексикографически упорядоченного
     диапазона букв;

[<b>цифра1-цифра2</b>]
     любая цифра из данного диапазона цифр;

<b>рег_выражение*</b>
     0 или более вхождений регулярного выражения;

<b>рег_выражение+</b>
     1 или более вхождений регулярного выражения;

<b>рег_выражение?</b>
     0 или 1 вхождение регулярного выражения;

<b>рег_выражение1 рег_выражение2</b>
     последовательное     вхождение     рег_выражение1     и
     рег_выражение2;

<b>рег_выражение1|рег_выражение2</b>
     вхождение <b>рег_выражение1</b> или <b>рег_выражение2</b>;


     Рассмотрим несколько примеров использования  регулярных
выражений:

<b>/^Иванов/</b>
     выделить запись, начинающуюся цепочкой  символов  "Ива-
     нов"  Таким  образом,  будут выделены случаи типа "Ива-
     нову", "Ивановой", ... ;

<b>$3 ~ /^Иванов/</b>
     выделить  запись,  в  которой  третье  поле  начинается
     цепочкой символов "Иванов";

<b>/([abc][ABC])$/</b>
     выделить запись, предпоследним символом  которой  явля-
     ется одна из букв abc и последним - одна из букв ABC;

<b>/[0-9]+/</b>
     выделить запись, содержащую не менее одной цифры;

<b>$3 !~ /(Сидор)|(Петр)/</b>
     не выделять запись, содержащую в третьем поле  что-либо
     о Сидорах или Петрах;


     Ниже приведен пример  AWK-программы,  печатающей  имена
регистрационных  каталогов  и  имена всех пользователей сис-
темы, которыми не установлен пароль:

    <b>BEGIN  {</b>
            <b>FS</b> = ":";
            <b>print</b>("Имя\tКаталог");
    <b>}</b>

    $2 <b>!~ /</b>(([0<b>-</b>9])<b>|</b>([a<b>-</b>z])<b>|</b>([A<b>-</b>Z]))<b>+/  {</b>
            <b>print</b>( $1, "\t", $6);
    <b>}</b>

В первом правиле (селектор <b>BEGIN</b>) меняется разделитель полей
записи  с  пробела  на двоеточие (такова структура записей в
парольном файле /<b>etc</b>/<b>passwd</b> операционной системы ДЕМОС).  Во
втором поле записи парольного файла содержится зашифрованный
пароль - обычно это комбинация цифр и букв.  Если пароль  не
установлен, то второе поле записи пусто. Этот факт использо-
ван для формирования  селектора  -  второе  поле  не  должно
содержать  цифр и букв. Селектор выделяет второе поле записи
и проверяет наличие не менее одного  символа  в  этом  поле.
Если поле пусто, выполняется действие, которое заключается в
печати имени пользоватея (первое поле) и имени регистрацион-
ного каталога пользователя (шестое поле).

     Иногда  необходимо  определить  диапазон  записей,  для
которых  выполняется  действие. Например, необходимо вывести
на печать записи с номерами от 10 до 20  включительно.  Или,
допустим,  вывести  на  печать  поле  номер 6 каждой записи,
начиная с той, в которой второе поле "Петр", до той, в кото-
рой  пятое поле "Сидор". Для определения диапазона записей в
селекторах используется операция запятая. До запятой  указы-
вается селектор, выделяющий первую запись в диапазоне, после
запятой - селектор, выделяющий последнюю запись в диапазоне.
Таким  образом,  мы  имеем дело с составным селектором.  Для
всех записей диапазона выполняется действие правила  с  сос-
тавным селектором.

     Рассмотрим пример. Допустим, имеется следующий файл:

    sss   поле2 поле3 поле4  1
    поле1 sss   поле3 поле4  2
    поле1 поле2 sss   поле4  3
    поле1 поле2 поле3 sss    4
    ttt   поле2 поле3 поле4  5
    поле1 ttt   поле3 поле4  6
    поле1 поле2 ttt   поле4  7
    поле1 поле2 поле3 ttt    8

Допустим, необходимо вывести  на  печать  диапазон  записей.
Открывает этот диапазон запись, второе поле которой "sss", и
закрывает запись, третье поле которой "ttt". Тогда программа
выглядит следующим образом:

    $2 <b>~ /</b>sss<b>/, </b>$3 <b>~ /</b>ttt<b>/   {</b>
            <b>print</b>( $0 );
    <b>}</b>

В результате выполнения получим:

    поле1 sss   поле3 поле4  2
    поле1 поле2 sss   поле4  3
    поле1 поле2 поле3 sss    4
    ttt   поле2 поле3 поле4  5
    поле1 ttt   поле3 поле4  6
    поле1 поле2 ttt   поле4  7


     В одной программе можно указать несколько правил с сос-
тавными  селекторами.  При  этом  если  выделенные диапазоны
перекрываются, то каждая выделенная запись  будет  обрабаты-
ваться  несколькими  правилами. Например, для того же исход-
ного файла используется следующая программа обработки:

    $2 <b>~ /</b>sss<b>/, </b>$3 <b>~ /</b>ttt<b>/   {</b>
            <b>print</b>( $0 );
    <b>}</b>

    $1 <b>~ /</b>sss<b>/, NR ==</b> 5    <b>{</b>
            <b>print</b>($0, "*");
    <b>}</b>

    <b>NR ==</b> 6<b>, NR ==</b> 8       <b>{</b>
            <b>print</b>( $0, "&lt;-" );
    <b>}</b>

В результате выполнения получим:


    sss   поле2 поле3 поле4  1 *
    поле1 sss   поле3 поле4  2
    поле1 sss   поле3 поле4  2 *
    поле1 поле2 sss   поле4  3
    поле1 поле2 sss   поле4  3 *
    поле1 поле2 поле3 sss    4
    поле1 поле2 поле3 sss    4 *
    ttt   поле2 поле3 поле4  5
    ttt   поле2 поле3 поле4  5 *
    поле1 ttt   поле3 поле4  6
    поле1 ttt   поле3 поле4  6 &lt;-
    поле1 поле2 ttt   поле4  7
    поле1 поле2 ttt   поле4  7 &lt;-
    поле1 поле2 поле3 ttt    8 &lt;-


     Чтобы устранить эффект пересечения диапазонов  выделен-
ных  записей,  там,  где  это необходимо, можно использовать
оператор <b>next</b>. Этот оператор  прекращает  обработку  текущей
записи,  управление передается на начало программы и начина-
ется разбор следующей записи. Теперь программа  будет  иметь
вид:

    $2 <b>~ /</b>sss<b>/, </b>$3 <b>~ /</b>ttt<b>/   {</b>
            <b>print</b>( $0 );
            <b>next</b>;
    <b>}</b>

    $1 <b>~ /</b>sss<b>/, NR ==</b> 5    <b>{</b>
            <b>print</b>($0, "*");
            <b>next</b>;
    <b>}</b>

    <b>NR ==</b> 6<b>, NR ==</b> 8       <b>{</b>
            <b>print</b>( $0, "&lt;-" );
    <b>}</b>

В результате выполнения программы получим:

    sss   поле2 поле3 поле4  1 *
    поле1 sss   поле3 поле4  2
    поле1 поле2 sss   поле4  3
    поле1 поле2 поле3 sss    4
    ttt   поле2 поле3 поле4  5
    поле1 ttt   поле3 поле4  6
    поле1 поле2 ttt   поле4  7
    поле1 поле2 поле3 ttt    8 *

Из примера видно, что в исходном списке не нашлось ни  одной
записи,  которая была бы обработана всеми правилами и дейст-
вие третьего правила программы не выполнялось вообще.


     Если в результате выполнения правила с составным селек-
тором  выделено  начало диапазона записей, но не выделен его
конец, действие этого правила выполняется для  всех  записей
до  конца  ввода.  Если же не обнаружена запись, открывающая
диапазон записей, то действие правила с составным селектором
не выполняется.

<h3 id ="ch5">5.  Действия</h3>


     Действия в правилах AWK-программы  определяют  алгоритм
обработки  выделенных  селектором  записей. Для записи алго-
ритма используются присваивания, выражения, операторы управ-
ления, операторы вывода, встроенные функции.

     Выше было показано, что действие в правиле записывается
как  блок  (в  смысле  языка  программирования Си). Фигурная
скобка,  открывающая  блок,  должна  указываться  в  той  же
строке, что и селектор, закрывающая - по завершению блока. В
общем случае блок может быть пустым,  тогда,  как  это  было
сказано  выше, все записи, выделенные селектором, передаются
на стандартный вывод без преобразований.

     К числу операторов управления относятся:

<b>exit</b>
     завершить выполнение программы;

<b>next</b>
     перейти к чтению следующей записи.  Управление  переда-
     ется на первое правило AWK-программы (если имеется пра-
     вило с селектором <b>BEGIN</b>, то на следующее за ним);

<b>break</b>
     прерывает выполнение  охватывающего  цикла.  Управление
     передается на оператор, следующий за циклом;

<b>continue</b>
     переход к следующей итерации цикла;

<b>if(выражение) { блок_1 }  else { блок_2 }</b>
     если значение выражения - истина, выполняются операторы
     <b>блока_1</b>,  иначе  операторы  <b>блока_2</b>.  Часть  <b>else</b> можно
     опустить. Если <b>блок_1</b> или  <b>блок_2</b>  содержат  по  одному
     оператору, фигурные скобки можно не указывать;

<b>while(выражение) { блок }</b>
     операторы блока выполняются, пока значение выражения  -
     истина.   Если  в блоке только один оператор,  фигурные
     скобки можно не указывать;

<b>for(выражение_1; выражение_2; выражение_3) { блок }</b>
     если  значение  <b>выражения_2</b>   -   истина,   выполняются
     операторы  блока.  <b>Выражение_1</b> вычисляется перед первой
     итерацией цикла, <b>выражение_3</b> вычисляется на каждой ите-
     рации цикла. Если блок содержит один оператор, фигурные
     скобки можно не указывать.

<b>for( индекс in имя_массива ) { блок }</b>
     для каждого значения индекса массива выполняются опера-
     торы блока.  Значение индекса формируется автоматически
     на каждой итерации  цикла  и  равно  значению,  еще  не
     использованному  в цикле. Если используется ассоциатив-
     ный массив,  индекс  формируется  в  лексикографическом
     порядке.  Если  в блоке происходит добавление элементов
     массива, результат выполнения цикла непредсказуем. Если
     в блоке изменяется значение индекса, результат выполне-
     ния цикла непредсказуем.  Вместо  индекса  и/или  имени
     массива  можно  указать  выражение,  значение  которого
     интерпретируется как индекс и/или имя массива.


     В качестве условных выражений можно использовать  любые
из  описанных  выше.  В  выражениях можно применять шаблоны,
операторы <b>~</b> и <b>!~</b>. Рассмотрим пример:

    /aaa/ <b>{</b>
            <b>if</b>( $3 <b>!~ /</b>fff<b>/</b> )
                    <b>print</b>( $0 );
    <b>}</b>

В записи, выделенной по селектору <b>/aaa/</b>,  проверяется  соот-
ветствие  содержимого поля $3 шаблону <b>/fff/</b>.  Если соответс-
вие не обнаружено,  печатаеся  вся  запись,  иначе  оператор
<b>print</b> не выполняется.

     Теперь рассмотрим пример  использования  цикла  <b>for</b>  по
идексу  в  ассоциативном  массиве.  Допустим, имеется список
записей

    aaa aaa ddd ccc
    ccc ddd
    bbb ddd ddd
    ccc

и пусть выполняется программа

    /bbb≈/   <b>{ m</b>["bbb"]<b>++; }</b>

    /ccc≈/   <b>{ m</b>["ccc"]<b>++; }</b>

    /aaa≈/   <b>{ m</b>["aaa"]<b>++; }</b>

    /ddd≈/   <b>{ m</b>["ddd"]<b>++; }</b>

    <b>END     { for</b>( <b>i in m</b> )
                     <b>print</b>("m["i"] =", <b>m</b>[<b>i</b>]);
    <b>}</b>

В каждом из первых  четырех  правил  селекторами  выделяются
записи  и подсчитывается число таких записей в ассоциативном
массиве с именем <b>m</b>.   Цикл  <b>for</b>  выполняется  по  завершению
списка  входных  записей.  В результате выполнения программы
получим:

    m[aaa] = 1
    m[bbb] = 1
    m[ccc] = 3
    m[ddd] = 3

Значением каждого элемента массива является число выделенных
селекторами   записей.  В  результате  выполнения  цикла  по
индексу в ассоциативном массиве получен вывод значений  эле-
ментов   массива   в   лексикографическом  порядке  значений
индекса.

     Ниже приведен пример программы, действия которой содер-
жат примеры использования основных  управляющих конструкций.
Допустим, имеется следующий текст:

    aaa, aaa, aaa  aaa  aaa.
    aaa  aaa, aaa, aaa  aaa.
    aaa  aaa  aaa, aaa  aaa.
    aaa  aaa  aaa  aaa, aaa.
    aaa; aaa  aaa  aaa: aaa.
    aaa  aaa; aaa  aaa  aaa.
    aaa  aaa  aaa; aaa; aaa.
    aaa  aaa: aaa  aaa; aaa.
    aaa: aaa  aaa; aaa  aaa.
    aaa  aaa  aaa: aaa: aaa.

Требуется получить некоторую статистку о тексте:


# Программа вычисляет статистические
# характеристики текста.
# Разделитель записей точка.
# Разделитель полей пробел.
# Вывод результатов осуществляется
# после завершения входного текста.

<b>BEGIN {</b>
      # выделение и инициализация
      # переменных

      <b>RS</b> = "."; # разделитель записей
      <b>Nw</b> = 0;   # число слов
      <b>Nb</b> = 0;   # число символов в словах
      <b>Np</b> = 0;   # число запятых
      <b>Nd</b> = 0;   # число двоеточий
      <b>Nt</b> = 0;   # число точек с запятой
<b>}</b>

<b>{</b>
 <b>for</b>( <b>i</b> = 1; <b>i</b> &lt;<b>= NF</b>; <b>i++</b> )<b>{</b>
      <b>if</b>( $<b>i ~ /</b>,<b>$/</b> ) <b>{</b>
               <b>Np++;</b>
               <b>Nb--;</b>
      <b>}</b>

      # Nb--; не учитывать в длине
      # слова знак препинания

      <b>if</b>( $<b>i ~ /</b>:<b>$/</b> ) <b>{</b>
               <b>Nd++;</b>
               <b>Nb--;</b>
      <b>}</b>

      <b>if</b>( $<b>i ~ /</b>;<b>$/</b> ) <b>{</b>
               <b>Nt++;</b>
               <b>Nb--;</b>
      <b>}</b>

      <b>Nb += length</b>( $<b>i</b> ); # длина слова
      <b>Nw++;</b> # увеличить число слов
 <b>}</b>
<b>}</b>

<b>END    {</b>
      <b>print</b>("Число запятых =", <b>Np</b>);
      <b>print</b>("Число двоеточий =", <b>Nd</b>);
      <b>print</b>("Число точек с запятой =", <b>Nt</b>);
      <b>print</b>("Число слов =", <b>Nw</b>);
      <b>print</b>("Число символов в словах =", <b>Nb</b>);
      <b>print</b>("Число предложений =", <b>NR</b> );
      <b>print</b>("Средняя длина предл. =", <b>Nw/NR</b>,"(слов)");
      <b>print</b>("Средняя длина слова =", <b>Nb/Nw</b>);
<b>}</b>

Ниже показан результат работы программы:

    Число запятых = 6
    Число двоеточий = 5
    Число точек с запятой = 6
    Число слов = 50
    Число символов в словах = 150
    Число предложений = 10
    Средняя длина предл. = 5 (слов)
    Средняя длина слова = 3


<h3 id ="ch6">6.  Ввод и вывод данных в AWK-программах</h3>


     Ввод данных в AWK-программу определяется  именем  вход-
ного  файла в командной строке. Таких файлов может быть нес-
колько, и обрабатываться AWK-программой они будут последова-
тельно  в том порядке, в котором указаны в командной строке,
например:

    <b>awk  -f prog f1 f2 f3 f4</b>

AWK-программа из файла <b>prog</b> будет  выполняться  над  входным
потоком записей из файлов <b>f1</b>, <b>f2</b>, <b>f3</b> и <b>f4</b>.  Здесь необходимо
отметить, что предопределенная  переменная  <b>NR</b>  будет  иметь
значение,  равное  порядковому номеру записи ( <b>NR</b> не обнуля-
ется при переходе к чтению очередного файла).  Пусть имеются
четыре файла. Файл <b>f1</b>:

    a[1][1]  a[1][2]  a[1][3]  a[1][4]
    a[2][1]  a[2][2]  a[2][3]  a[2][4]
    a[3][1]  a[3][2]  a[3][3]  a[3][4]
    a[4][1]  a[4][2]  a[4][3]  a[4][4]

Файл <b>f2</b>:

    b[1][1]  b[1][2]  b[1][3]  b[1][4]
    b[2][1]  b[2][2]  b[2][3]  b[2][4]
    b[3][1]  b[3][2]  b[3][3]  b[3][4]
    b[4][1]  b[4][2]  b[4][3]  b[4][4]

Файл <b>f3</b>:

    c[1][1]  c[1][2]  c[1][3]  c[1][4]
    c[2][1]  c[2][2]  c[2][3]  c[2][4]
    c[3][1]  c[3][2]  c[3][3]  c[3][4]
    c[4][1]  c[4][2]  c[4][3]  c[4][4]

Файл <b>f4</b>:

    d[1][1]  d[1][2]  d[1][3]  d[1][4]
    d[2][1]  d[2][2]  d[2][3]  d[2][4]
    d[3][1]  d[3][2]  d[3][3]  d[3][4]
    d[4][1]  d[4][2]  d[4][3]  d[4][4]

Каждый из этих файлов включает по четыре записи  (по  четыре
поля  в  каждой).   Другими  словами,  каждый файл - матрица
(4*4).  Допустим, необходимо получить новую матрицу  с  раз-
мерностью  (4*4),  столбцы  которой  составлены из элементов
диагоналей исходных матриц. Ниже приведен текст программы, в
которой решается эта задача:

    <b>{</b>
        <b>if</b>( <b>FILENAME != Name</b> ) <b>{</b>
                <b>i</b> = 0;
                <b>Name = FILENAME;</b>
        <b>}</b>

        i<b>++;</b>
        <b>if</b>( <b>i ==</b> 1 ) <b>{</b>
                <b>Dig1 = Dig1</b> " " $1;
                <b>next;</b>
        <b>}</b>
        <b>if</b>( <b>i ==</b> 2 ) <b>{</b>
                <b>Dig2 = Dig2</b> " " $2;
                <b>next;</b>
        <b>}</b>
        <b>if</b>( <b>i ==</b> 3 ) <b>{</b>
                <b>Dig3 = Dig3</b> " " $3;
                <b>next;</b>
        <b>}</b>
        <b>if</b>( <b>i ==</b> 4 ) <b>Dig4 = Dig4</b> " " $4;
    <b>}</b>

    <b>END     {</b>
            <b>print</b>( <b>Dig1</b> );
            <b>print</b>( <b>Dig2</b> );
            <b>print</b>( <b>Dig3</b> );
            <b>print</b>( <b>Dig4</b> );
    <b>}</b>


     В программе два правила.  Первое  правило  не  содержит
селектора, следовательно, выполняется для всех входных запи-
сей.  Второе  правило  выполняется  по  завершению  входного
потока.  Программа работает следующим образом: первоначально
проверяется, изменилось ли имя входного  файла  (предопреде-
ленная  переменная  <b>FILENAME</b>),  затем,  если  не изменилось,
присваивается значение соответствующего поля записи к  пере-
менной  <b>Dig</b> (используется операция конкатенации старого зна-
чения <b>Dig</b> со значением поля и присваивания <b>Dig</b> нового значе-
ния).  Переменная  <b>Name</b>  предназначена  для сохранения имени
входного файла. Первоначально значения переменных <b>Name</b> и <b>Dig</b>
равны  пустым строкам. Важно, что мы знаем точно число запи-
сей, это позволяет выделять нужные поля в  записях.   Допус-
тим, выполняется следующая командная строка:

    <b>awk -f prog  f1 f2 f3 f4</b> &gt; <b>Result</b>

в файле <b>Result</b> будем иметь:

    a[1][1] b[1][1] c[1][1] d[1][1]
    a[2][2] b[2][2] c[2][2] d[2][2]
    a[3][3] b[3][3] c[3][3] d[3][3]
    a[4][4] b[4][4] c[4][4] d[4][4]

Результат работы программы  существенно  связан  с  порядком
чтения входных файлов. Если выполнить командную строку

    <b>awk -f prog  f4 f3 f2 f1</b> &gt; <b>Result</b>

получим:

    d[1][1] c[1][1] b[1][1] a[1][1]
    d[2][2] c[2][2] b[2][2] a[2][2]
    d[3][3] c[3][3] b[3][3] a[3][3]
    d[4][4] c[4][4] b[4][4] a[4][4]


     Когда возникает необходимость передать в  AWK-программу
значения некоторых переменных, можно воспользоваться возмож-
ностью указать их в файле.  Допустим,  заранее  не  известны
образцы  для выделения записей файла <b>f1</b>. В этом случае можно
создать файл <b>f0</b> с описаниями  образцов  и,  воспользовавшись
значением  переменной  <b>FILENAME</b>,  присвоить  этим переменным
нужные значения. Пусть файл <b>f0</b> имеет вид:

    aaa bbb ccc

Пусть файл <b>f1</b> имеет вид:

    aaa bbb ccc ddd eee
    eee bbb ccc ddd aaa
    aaa fff ccc ddd eee
    aaa bbb ggg ttt eee

Программа на AWK:

    <b>FILENAME ==</b> "f0" <b>{</b>
            <b>pat1 =  </b>$1;
            <b>pat2 =  </b>$2;
            <b>pat3 =  </b>$3;
            <b>next;</b>
    <b>}</b>

    $1 <b>== pat1 { print; next }</b>
    $2 <b>== pat2 { print; next }</b>
    $3 <b>== pat3 { print }</b>

После выполнения командной строки

    <b>awk -f prog f0 f1</b>

получим в файле <b>Result</b>:

    aaa bbb ccc ddd eee
    aaa fff ccc ddd eee
    aaa bbb ggg ttt eee


     Можно предусмотреть  ввод  переменных  со  стандартного
ввода;  воспользуемся тем, что переменная <b>FILENAME</b> для стан-
дартного ввода определена как "<b>-</b>".  Пусть файл <b>f1</b> имеет вид:

    aaa bbb ccc ddd eee
    eee bbb ooo ddd aaa
    aaa fff ccc ddd eee
    qqq bbb ggg ttt eee
    ooo fff ggg ttt eee
    ccc bbb ggg ttt eee

Приведенная ниже программа позволяет получить значения пере-
менных с клавиатуры дисплея:

    <b>BEGIN   { print</b>("Вводите значения полей:")<b>; }</b>

    <b>FILENAME ==</b> "<b>-</b>" <b>{</b>
            <b>pat1 =  </b>$1;
            <b>pat2 =  </b>$2;
            <b>pat3 =  </b>$3;
    <b>}</b>

    <b>FILENAME ==</b> "<b>f1</b>" <b>{</b>
            <b>if</b>($1 <b>== pat1</b>) <b>{ print</b>($0)<b>; next }</b>
            <b>if</b>($2 <b>== pat2</b>) <b>{ print</b>($0)<b>; next }</b>
            <b>if</b>($3 <b>== pat3</b>) <b>{ print</b>($0)<b>;}</b>
    <b>}</b>

После запуска на выполнение следующей командной строки

    <b>awk -f prog - f1</b>

программа будет ждать ввода с клавиатуры дисплея  (завершить
ввод необходимо символом конец файла - <b>CTRL/D</b>). Например:

    Вводите значения полей:
    qqq fff ooo
    <b>CTRL/D</b>
    eee bbb ooo ddd aaa
    aaa fff ccc ddd eee
    qqq bbb ggg ttt eee
    ooo fff ggg ttt eee


     Как уже говорилось раньше, вывод AWK-программы  направ-
ляется  на  экран  дисплея,  если  не  было  указано другое.
Существует возможность направить вывод по нескольким каналам
непосредственно из AWK-программы, для этого можно воспользо-
ваться стандартными средствами системы ДЕМОС.  Например:

    <b>print</b>( $0 ) &gt; "<b>file</b>";

запись будет направлена в файл с именем ./<b>file</b>;

    <b>print</b>( $0 ) &gt;&gt; "<b>file</b>";

запись будет дописана в ./<b>file</b>;

    <b>print</b>( $0 ) &gt; $2;

запись будет направлена в файл с именем, равным  содержимому
ее второго поля.

     Существует возможность из AWK-программы направить вывод
в конвейер, например:

    <b>{</b>
       <b>print</b>($0) <b>|</b> "<b>tr</b> ' ' '\n' <b>| sort</b> ";
    <b>}</b>

Здесь запись будет направлена команде  <b>tr</b>,  которая  заменит
пробел символом '\n', затем отсортирована командой <b>sort</b>.

     Пусть выполнена следующая командная строка:

    <b>awk -f prog -</b>

после ввода с клавиатуры нескольких записей

    dfa nrk klm njf rty xvz
    saa ass dcf vfr klm ttr
    <b>CTRL/D</b>

получим:

    ass
    dcf
    dfa
    klm
    klm
    njf
    nrk
    rty
    saa
    ttr
    vfr
    xvz

Вывод результата работы конвейера осуществляется по заверше-
нию  чтения последней входной записи. Канал вывода в примере
совпадает с каналом стандартного вывода, но его можно  пере-
определить на любой файл.

     В одной  AWK-программе  можно  одновременно  определить
несколько  каналов  вывода,  число  которых зависит от числа
файлов, разрешенных для  одновременного  использования.  Это
число  устанавливается  при  генерации  операционной системы
ДЕМОС.

     Для вывода данных в AWK-программе предназначен оператор
<b>print</b>.   До  настоящего момента мы применяли лишь одну форму
использования этого оператора:

    <b>print</b>(<b>список_фактических_параметров</b>);

Круглые скобки использовались раньше для того, чтобы не отв-
лекать  читателя,  знакомого с языком программирования Си, -
их можно не указывать. Существуют и другие формы использова-
ния этого оператора:

<b>print;</b>
     выводится вся запись;

<b>print </b>$1, $2;
     значения полей выводятся через пробел;

<b>print </b>$1 $2;
     выводится конкатенация значений полей.


     При  необходимости  управления  форматом  вывода  можно
использовать   библиотечную   функцию  <b>printf</b>,  синтаксис  и
результат работы  которой такие же, как и в языке Си.



<h3 id ="ch7">7.  Использование встроенных функций</h3>


     Интерпретатор <b>awk</b> включает  набор  встроенных  функций,
которые  можно  использовать в действиях правил.  Существуют
два способа вызова встроенных функций:

    <b>имя_функции</b>(<b>список_фактических_параметров</b>)

    <b>имя_функции</b>

Во втором случае в качестве фактического параметра  применя-
ется  вся текущая запись. Как обычно, значение функции подс-
тавляется в выражение в том месте, где определен вызов.

     Имеются следующие встроенные функции:

<b>length</b>(<b>выражение</b>)
     значением выражения является  строка.   Функция  <b>length</b>
     возвращает длину строки, например:

         <b>print</b>( <b>length</b>($1 " " $2));

     будет напечатана длина строки, полученной конкатенацией
     поля  $1, пробела и поля $2.  Форма без аргумента возв-
     ращает длину записи.

<b>exp</b>(<b>выражение</b>)
     возвращает экспоненту от выражения.

<b>log</b>(<b>выражение</b>)
     возвращает натуральный логарифм выражения.

<b>sqrt</b>(<b>выражение</b>)
     возвращает значение квадратного корня от выражения.

<b>int</b>(<b>выражение</b>)
     возвращает целую часть числа, равного значению  выраже-
     ния.

<b>substr(S</b>, <b>M</b>, <b>N</b>)
     возвращает часть строки <b>S</b>, начинающуюся от позиции <b>M</b>  и
     имеющую  длину  не более <b>N</b> символов. Символы в строке <b>S</b>
     нумеруются с 1.  Если аргумент <b>N</b> не указан,   возвраща-
     ются все символы от <b>M</b> до конца строки.

         <b>string = substr</b>( $0, 12, 20);

     <b>String</b> будет включать 9 символов (с 12 по  20)  текущей
     записи.

<b>index</b>(<b>As</b>, <b>Ps</b>)
     возвращает номер позиции, с которой строка <b>Ps</b> совпадает
     со строкой <b>As</b>. Если совпадения нет, возвращается 0.

<b>sprintf</b>(<b>формат</b>, <b>выражение</b>, ...)
     возвращает строку,  выведенную  по  формату.  Синтаксис
     функции и результат работы аналогичны функции <b>sprintf</b> в
     библиотеке языка программирования Си.

<b>split( S, Name, разделитель )</b>
     строка <b>S</b> разбивается на поля, значения которых присваи-
     ваются  элементам  массива <b>Name</b>. Значением первого эле-
     мента  <b>Name</b>[1]  будет  содержимое  первого  выделенного
     поля,  значением  второго  элемента  <b>Name</b>[2]  - второго
     выделенного поля и так далее.  Если не указан  раздели-
     тель   полей,  используется  значение  предопределенной
     переменной <b>FS</b>.  Функция <b>split</b> возвращает число выделен-
     ных полей. Рассмотрим пример.  Пусть имеется файл <b>f1</b>

         aaa bbb ccc# ddd# eee fff# ggg
         ttt# ggg eee# ccc ddd sss# yyy

     и AWK-программа

         <b>{</b>
           <b>i = split</b>( $0, <b>Name</b>, "#");
           <b>for</b>(<b>j</b> = 1; <b>j</b> &lt;<b>= i</b>; <b>j++</b>)
               <b>print</b>( "Name["j"] =", <b>Name</b>[<b>j</b>]);
         <b>}</b>

     после выполнения командной строки

         <b>awk -f prog f1</b>

     получим:

         Name[1] = aaa bbb ccc
         Name[2] =  ddd
         Name[3] =  eee fff
         Name[4] =  ggg
         Name[1] = ttt
         Name[2] =  ggg eee
         Name[3] =  ccc ddd sss
         Name[4] =  yyy


</pre>
</body>
</html>
